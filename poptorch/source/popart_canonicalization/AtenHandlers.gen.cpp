// DO NOT EDIT! Generated by PopAtenHandlers.py
// Copyright (c) 2020 Graphcore Ltd. All rights reserved.

#include "../PoptorchStaticInit.hpp"
#include "../PoptorchSymbols.hpp"
#include "PopartCanonicalizationUtils.hpp"
#include "poptorch/OpBuilder.hpp"
#include "poptorch_logging/Error.hpp"
#include "poptorch_logging/Logging.hpp"

namespace poptorch {

namespace {

torch::jit::Node *addmmHandler(torch::jit::Graph *graph,
                               torch::jit::Node *node) {
  auto y = node->input(1);
  auto z = node->input(2);
  auto x = node->input(0);
  auto c1 = node->input(3);
  auto t0 = constantToFloat(c1->node());
  auto c2 = node->input(4);
  auto t1 = constantToFloat(c2->node());
  // gemm(y, z, x, NonTensorFloat(c1), NonTensorFloat(c2), 0, 0)
  return createGemm(graph, {y, z, x}, t0, t1, 0, 0);
}

torch::jit::Node *atan2Handler(torch::jit::Graph *graph,
                               torch::jit::Node *node) {
  auto i0 = node->input(0);
  auto i1 = node->input(1);
  // atan2(i0, i1)
  return createAtan2(graph, {i0, i1});
}

torch::jit::Node *catHandler(torch::jit::Graph *graph, torch::jit::Node *node) {
  auto x = node->input(0);
  auto t0 = handleTensorList(x->node());
  auto y = node->input(1);
  auto t1 = constantToLong(y->node());
  // concat(TensorList(x), NonTensorLong(y))
  return createConcat(graph, {t0}, t1);
}

torch::jit::Node *celuHandler(torch::jit::Graph *graph,
                              torch::jit::Node *node) {
  auto x = node->input(0);
  auto t0 = createConstantFloat32(graph, {0.0}, {})->output();
  auto t1 = createMax(graph, {x, t0})->output();
  auto a = node->input(1);
  auto t2 = createDiv(graph, {x, a})->output();
  // matched expm1: sub(exp(x), 1.0)
  auto t3 = createExpm1(graph, {t2})->output();
  auto t4 = createMul(graph, {a, t3})->output();
  auto t5 = createMin(graph, {t0, t4})->output();
  // add(max(x, 0.0), min(0.0, mul(a, expm1(div(x, a)))))
  return createAdd(graph, {t1, t5});
}

torch::jit::Node *clampHandler(torch::jit::Graph *graph,
                               torch::jit::Node *node) {
  auto x = node->input(0);
  auto z = node->input(2);
  auto t0 = constantToFloat(z->node());
  auto y = node->input(1);
  auto t1 = constantToFloat(y->node());
  // clip(x, NonTensorFloat(z), NonTensorFloat(y))
  return createClip(graph, {x}, t0, t1);
}

torch::jit::Node *dropoutHandler(torch::jit::Graph *graph,
                                 torch::jit::Node *node) {
  auto x = node->input(0);
  auto y = node->input(1);
  auto t0 = constantToFloat(y->node());
  // dropout(x, 1, NonTensorFloat(y))
  return createDropout(graph, {x}, 1, t0);
}

torch::jit::Node *maskedfillHandler(torch::jit::Graph *graph,
                                    torch::jit::Node *node) {
  auto i1 = node->input(1);
  auto i2 = node->input(2);
  auto i0 = node->input(0);
  // where(i1, i2, i0)
  return createWhere(graph, {i1, i2, i0});
}

torch::jit::Node *minHandler(torch::jit::Graph *graph, torch::jit::Node *node) {
  if (node->inputs().size() == 1) {
    auto x = node->input(0);
    auto t0 = reduceHelperDimensionCreator(x);
    // reducemin(x, DimensionList(x), 0)
    return createReducemin(graph, {x}, t0, 0);
  }
  if (node->inputs().size() == 2) {
    auto i0 = node->input(0);
    auto i1 = node->input(1);
    // min(i0, i1)
    return createMin(graph, {i0, i1});
  }
  ERROR("Unhandled arity for operator c10::aten::min");
  return nullptr;
}

torch::jit::Node *normalInPlaceHandler(torch::jit::Graph *graph,
                                       torch::jit::Node *node) {
  auto x = node->input(0);
  auto t0 = shapeFromTensor(x);
  auto c1 = node->input(1);
  auto t1 = constantToFloat(c1->node());
  auto c2 = node->input(2);
  auto t2 = constantToFloat(c2->node());
  // randomNormal(x, TensorShape(x), NonTensorFloat(c1), NonTensorFloat(c2))
  return createRandomNormal(graph, {x}, t0, t1, t2);
}

torch::jit::Node *powHandler(torch::jit::Graph *graph, torch::jit::Node *node) {
  auto i0 = node->input(0);
  auto i1 = node->input(1);
  // pow(i0, i1)
  return createPow(graph, {i0, i1});
}

torch::jit::Node *reluHandler(torch::jit::Graph *graph,
                              torch::jit::Node *node) {
  auto i0 = node->input(0);
  // relu(i0)
  return createRelu(graph, {i0});
}

torch::jit::Node *rsqrtHandler(torch::jit::Graph *graph,
                               torch::jit::Node *node) {
  auto x = node->input(0);
  auto t0 = createSqrt(graph, {x})->output();
  // matched reciprocal: div(1.0, x)
  // reciprocal(sqrt(x))
  return createReciprocal(graph, {t0});
}

torch::jit::Node *seluHandler(torch::jit::Graph *graph,
                              torch::jit::Node *node) {
  auto x = node->input(0);
  // selu(x, 1.6732632423543772, 1.0507009873554805)
  return createSelu(graph, {x}, 1.6732632423543772, 1.0507009873554805);
}

torch::jit::Node *softplusHandler(torch::jit::Graph *graph,
                                  torch::jit::Node *node) {
  auto x = node->input(0);
  auto beta = node->input(1);
  auto t0 = createMul(graph, {x, beta})->output();
  auto threshold = node->input(2);
  auto t1 = createGreater(graph, {t0, threshold})->output();
  auto t2 = createMul(graph, {beta, x})->output();
  auto t3 = createExp(graph, {t2})->output();
  // matched log1p: log(add(1.0, x))
  auto t4 = createLog1p(graph, {t3})->output();
  // matched div: mul(div(1.0, y), x)
  auto t5 = createDiv(graph, {t4, beta})->output();
  // where(greater(mul(x, beta), threshold), x, div(log1p(exp(mul(beta, x))),
  // beta))
  return createWhere(graph, {t1, x, t5});
}

torch::jit::Node *squareHandler(torch::jit::Graph *graph,
                                torch::jit::Node *node) {
  auto i0 = node->input(0);
  // mul(i0, i0)
  return createMul(graph, {i0, i0});
}

torch::jit::Node *subHandler(torch::jit::Graph *graph, torch::jit::Node *node) {
  auto x = node->input(0);
  auto y = node->input(1);
  auto a = node->input(2);
  auto t0 = createMul(graph, {y, a})->output();
  auto t1 = hasUnityValue(a) ? y : t0;
  // sub(x, alpha(y, a, mul(y, a)))
  return createSub(graph, {x, t1});
}

torch::jit::Node *whereHandler(torch::jit::Graph *graph,
                               torch::jit::Node *node) {
  auto i0 = node->input(0);
  auto i1 = node->input(1);
  auto i2 = node->input(2);
  // where(i0, i1, i2)
  return createWhere(graph, {i0, i1, i2});
}

} // namespace

__attribute__((constructor(HANDLER_INIT_PRIORITY))) static void registration() {
  registerHandler(c10::aten::addmm, addmmHandler);
  registerHandler(c10::aten::atan2, atan2Handler);
  registerHandler(c10::aten::cat, catHandler);
  registerHandler(c10::aten::celu, celuHandler);
  registerHandler(c10::aten::clamp, clampHandler);
  registerHandler(c10::aten::dropout, dropoutHandler);
  registerHandler(c10::aten::masked_fill, maskedfillHandler);
  registerHandler(c10::aten::masked_fill_, maskedfillHandler);
  registerHandler(c10::aten::min, minHandler);
  registerHandler(c10::aten::normal_, normalInPlaceHandler);
  registerHandler(c10::aten::pow, powHandler);
  registerHandler(c10::aten::relu, reluHandler);
  registerHandler(c10::aten::relu_, reluHandler);
  registerHandler(c10::aten::rsqrt, rsqrtHandler);
  registerHandler(c10::aten::selu, seluHandler);
  registerHandler(c10::aten::selu_, seluHandler);
  registerHandler(c10::aten::softplus, softplusHandler);
  registerHandler(c10::aten::square, squareHandler);
  registerHandler(c10::aten::sub, subHandler);
  registerHandler(c10::aten::where, whereHandler);
  registerHandler(c10::aten::where_, whereHandler);
}

} // namespace poptorch
